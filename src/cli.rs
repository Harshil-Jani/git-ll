use inquire::{MultiSelect, Select};
use std::process::Command;

use crate::clap_config::{Cli, Commands};
use crate::llama::{ask_llama, check_ollama_setup};

pub async fn handle_cli(cli: Cli) {
    match &cli.command {
        Commands::Ask { prompt } => {
            let check_ollama = check_ollama_setup();
            match check_ollama {
                Ok(_) => {}
                Err(e) => {
                    println!("{}", e);
                    return;
                }
            }
            let msg = process_ask(prompt.to_string()).await;
            termimad::print_inline(&msg);
        }
        Commands::Diff { commit1, commit2 } => {
            let check_ollama = check_ollama_setup();
            match check_ollama {
                Ok(_) => {}
                Err(e) => {
                    println!("{}", e);
                    return;
                }
            }
            let diff_msg = process_diff(commit1.clone(), commit2.clone()).await;
            termimad::print_inline(&diff_msg);
        }
        Commands::Add { option } => {
            process_add(option).await;
        }
        Commands::Commit => {
            let check_ollama = check_ollama_setup();
            match check_ollama {
                Ok(_) => {}
                Err(e) => {
                    println!("{}", e);
                    return;
                }
            }
            process_commit().await;
        }
        Commands::Checkout { option } => {
            process_checkout(option).await; 
        },
        Commands::Delete => {
            process_delete().await;
        },
    }
}

async fn process_ask(prompt: String) -> String {
    println!("{}", prompt);
    let response = ask_llama(prompt.to_string()).await.unwrap();
    response
}

async fn process_diff(commit1: Option<String>, commit2: Option<String>) -> String {
    let (args, description) = prepare_diff_args_and_description(&commit1, &commit2);

    println!("{}", description);
    let output = Command::new("git")
        .args(&args)
        .output()
        .expect("Failed to execute git diff");

    let output_str = String::from_utf8_lossy(&output.stdout).to_string();
    let prompt = format!(
        "Take a look at the diff generated by git and summarize the changes into concise points, providing a file-wise summary: {}",
        output_str
    );
    let response = ask_llama(prompt)
        .await
        .expect("Failed to get summary from LLaMA");
    response
}

fn prepare_diff_args_and_description<'a>(
    commit1: &'a Option<String>,
    commit2: &'a Option<String>,
) -> (Vec<&'a str>, String) {
    match (commit1, commit2) {
        (Some(c1), Some(c2)) => (
            vec!["diff", &c1, &c2],
            format!("Diffing commits {} and {}", c1, c2),
        ),
        (Some(c1), None) => (
            vec!["diff", &c1],
            format!("Diffing commit {} with HEAD", c1),
        ),
        (None, Some(c2)) => (
            //This case is never gonna occur
            vec!["diff", "HEAD", &c2],
            format!("Diffing HEAD with commit {}", c2),
        ),
        (None, None) => (
            vec!["diff"],
            "Diffing unstaged changes with HEAD".to_string(),
        ),
    }
}

async fn process_add(option: &Option<String>) {
    match option {
        Some(s) => {
            match s.as_str() {
                "all" | "." => {
                    prepare_for_staging(true);
                }
                _ => {
                    // Show error since we don't support other options
                    println!("Invalid option. Do you mean 'git-ll add all' or `git-ll add .`?");
                }
            }
        }
        None => {
            prepare_for_staging(false);
        }
    }
}

fn prepare_for_staging(all_files: bool) {
    let output = Command::new("git")
        .args(&["status", "--porcelain"])
        .output()
        .expect("Failed to execute git status");

    let output_str = String::from_utf8_lossy(&output.stdout).to_string();

    let files: Vec<&str> = output_str
        .lines()
        .map(|line| line.split_whitespace().last().unwrap())
        .collect();

    let mut selected_files = MultiSelect::new("Select files to add", files);
    if all_files {
        selected_files = selected_files.with_all_selected_by_default();
    }
    let selected_files = selected_files.prompt().unwrap();
    add_to_staging(selected_files);
}
fn add_to_staging(files: Vec<&str>) {
    Command::new("git")
        .args(&["add"])
        .args(files)
        .output()
        .expect("Failed to execute git add");
}

async fn process_commit() {
    let diff_msg = process_diff(Some("--staged".to_string()), Some("HEAD".to_string())).await;
    let prompt = format!("Please read the following diff analysis for my changeset and based on it write me a commit message in around 15 words or less focussing only on major updates and just respond with msg only nothing else: {}", diff_msg);
    let msg = ask_llama(prompt)
        .await
        .expect("Failed to get commit message from LLaMA");
    println!("{}", msg);
    let confirm = Select::new(
        "Does the above commit msg looks good to you? Do you want to commit the changes?",
        vec!["Yes", "No"],
    )
    .prompt()
    .unwrap();
    if confirm == "Yes" {
        Command::new("git")
            .args(&["commit", "-m", &msg])
            .output()
            .expect("Failed to execute git commit");
    } else {
        println!("You can write a commit message manually using `git commit -m 'msg'`");
    }
}


async fn process_checkout(option: &Option<String>) {
    match option {
        Some(s) => {
            match s.as_str() {
                "remote" => {
                    checkout_branch(true);
                }
                "local" => {
                    checkout_branch(false);
                }
                _ => {
                    // Show error since we don't support other options
                    println!("Invalid option. Do you mean 'git-ll checkout' or `git-ll checkout remote`?");
                }
            }
        }
        None => {
            checkout_branch(false);
        }
    }
}

fn checkout_branch(remote : bool) {
    let mut args = vec!["branch"];
    
    if remote {
        args.push("-a");
    }
    
    let output = Command::new("git")
        .args(&args)
        .output()
        .expect("Failed to execute git command");

    let output_str = String::from_utf8_lossy(&output.stdout).to_string();

    let branches: Vec<&str> = output_str
        .lines()
        .map(|line| line.split_whitespace().last().unwrap())
        .collect();

    let selected_branch = Select::new("Select branch to checkout", branches).prompt().unwrap();

    Command::new("git")
        .args(&["checkout", selected_branch])
        .output()
        .expect("Failed to execute git checkout");

    println!("Checked out to branch {}", selected_branch);
}

async fn process_delete() {
    let output = Command::new("git")
        .args(&["branch"])
        .output()
        .expect("Failed to execute git command");

    let output_str = String::from_utf8_lossy(&output.stdout).to_string();

    let branches: Vec<&str> = output_str
        .lines()
        .map(|line| line.split_whitespace().last().unwrap())
        .collect();

    let selected_branch = MultiSelect::new("Select branches to delete", branches).prompt().unwrap();

    for branch in selected_branch
    {
        Command::new("git")
        .args(&["branch", "-d", branch])
        .output()
        .expect("Failed to execute git branch delete");

        println!("Deleted branch {}", branch);
    }

}